////
////  main.swift
////  SwiftTest
////
////  Created by Александр Филиппов on 27.03.2019.
////  Copyright © 2019 Philalex. All rights reserved.
////
//
import Foundation
//
////Простые типы данных 1 урок:
////Тип данных
////Описание
////Диапазон
////Int
////Целочисленный тип
////Диапазон соответствует разрядности ОС-Int32 или Int64
////UInt
////Целочисленный тип, только с положительными значениями
////Диапазон соответствует разрядности ОС-UInt32 или UInt64
////Double
////64-битное число с плавающей
////точкой
////15 десятичных цифр
////Float
////32-битное число с плавающей
////точкой
////6 десятичных цифр
////Bool
////Логический тип
////Может принимать значение true и false
////Character
////Символьный тип
////Один символ
////String
////Строка
////Любые символы
//
//
//
////Базовые операторы  2 урок:
////Присваивание: =.
////Арифметические: +, -, /, *, %.
////Составное присваивание: +=, -=, /=, *=, %=.
////Сравнения: <, >, ==, !=, <=, >=.
////Логические: !, &&, ||.
////Логическое И («&&») возвращает «true» только в том случае, когда оба его аргумента равны «true».
////true && true
////false && true
////true && false
////false && false
////true
////false
////false
////false
//
//
////Логическое ИЛИ («||») возвращает «true», если хотя бы один из его аргументов равен «true».
////true || true
////false || true
////true || false
////false || false
////true
////true
////true
////false
////
////Логическое НЕ («!») меняет значение на противоположное. В отличие от остальных, он принимает только один аргумент, точнее, просто ставится перед значением.
////!false
////!true
////true
////false
//
//
//
////Циклические операторы 2 урок:
///*Цикл повторяет блок кода некоторое количество раз.
//For-in: перебирает коллекцию или диапазон.
//While и repeat-while: выполняется, пока его условие истинно (true).*/
//
////For-in
////Основное назначение этого оператора – итерации по коллекциям. При этом на каждой итерации в тело цикла передается текущий элемент коллекции.
////for имя_элемента in коллекция { тело цикла }
//
//
////for имя_элемента in (a...b) { тело цикла } // где0 0a и b - целые числа
////for имя_элемента in (1...5) { тело цикла } // выполнится 5 итераций: 1 2 3 4 5
////for _ in (1...5) {print(1) }           // вместо имени переменной можно указать прочерк. В этом случае она не будет передаваться в тело цикла
//
////Иногда возникает необходимость итерировать некоторый диапазон шагом, отличным от 1. Например, вам нужно обработать числа от 7 до 18 с шагом 2. В этом случае на помощь приходит «stride» – эта функция создает определенный диапазон с указанным шагом. Есть два варианта данной функции:
////stride(from: a, through: b, by: n) // Создает диапазон от "a" до "b" включительно, с шагом n
////stride(from: a, to: b, by: n)     // Создает диапазон от "a" до "b", не включая "b", с шагом n
//
////Особенность цикла «for» в языке Swift – возможность уточнить, для каких итераций стоит выполнять тело цикла, а для каких – нет.
////for имя_элемента in коллекция where логическое_выражение { тело цикла }
//
////While
////Цикл, созданный с помощью этого оператора, будет выполняться, пока указанное при создании условие истинно. Чаще всего используется в тех случаях, когда заранее неизвестно, сколько итераций должен выполнить цикл, но известно условие, при котором оно должно выполняться.
////Важно понимать, что условие проверяется до выполнения тела цикла, и если в момент запуска цикла условие ложно, то цикл не выполнится ни разу.
////while условие { тело_цикла }
//
////Repeat-while
////    Цикл, почти идентичный «while», но с одной оговоркой: он выполняет тело цикла до проверки условия, а не после. Поэтому если в момент запуска циклов условие ложно, то «while» не выполнится ни разу, а «repeat-while» выполнится один раз.
////
////repeat {
////    тело_цикла
////} while условие
//
//
//
//// if - else 2 урок
//
////let x = 10
////if x == 10 {           // условие верно, код в блоке выполнится
////    print('perform')
////} else if x <= 10 {   // условие верно, но код в блоке уже не выполнится
////    print('perform again')
////} else {
////    print("default")
////}
//
//
//
//// switch { case } 2 урок
//
////switch значение для проверки {
////    case вариант 1:
////    блок кода
////    fallthrough  /// вставляется чтобы выполнить следующий case
////    case вариант 2, вариант 3:
////    блок кода
////    default:
////    блок кода  // выполняется, если ни один из вариантов не будет соответствовать значению
////}
////Сравнение вариантов со значением идет сверху вниз. После того как будет найден подходящий вариант и выполнится его блок кода, остальные варианты сравниваться не будут. Так, если в «switch» будет несколько вариантов, соответствующих значению, выполнится только один.
////В других языках по умолчанию выполняются все блоки «case», что находятся ниже подходящего варианта. Но в Swift такое поведение выключено. Чтобы его включить, надо добавить ключевое слово «fallthrough» в «case».
//
////Операторы передачи управления
////По умолчанию цикл выполняет все свои итерации. Иногда возникает необходимость не выполнять тело цикла до конца, а, пропустив оставшуюся часть, сразу перейти к следующей итерации, а возможно, и прервать выполнение цикла целиком. Для этого у нас есть два оператора передачи управления:
////«continue» – завершает выполнение тела цикла в месте вызова и переходит к следующей итерации;
////«break» – завершает выполнение тела цикла в месте вызова и останавливает выполнение цикла.
//
//
//
//
//// Функции - 2 урок:
///*Переиспользуемый блок кода.
//Определение функции начинается с func.
//Принимает аргументы.
//Может вернуть значение.
//Guard – выход из области видимости, если условие ложно.*/
//
////Функция – это блок кода, который можно переиспользовать в любом месте программы сколько угодно раз.
////Использование функции называется «вызов». Другими словами, если вам необходимо где-то выполнить блок кода из функции, вы ее вызываете. Функция имеет имя, по которому мы отличаем ее от других и можем вызывать.
////Параметры могут быть входными – те, что передаются функции во время вызова и используются внутри функции. А могут быть выходными – те, что можно получить от функции и использовать в месте вызова. Так, функция «sqrt» принимает число, вычисляет его корень и возвращает результат своих вычислений. Значение, которое возвращает функция, можно использовать в выражении, а можно присвоить его переменной. Возвращаемое значение также называют результатом функции.
////sqrt(4)               // мы передали функции параметр «4», она вернула новое значение «2», которое мы никак не использовали
////let x = sqrt(4)      // здесь мы присваиваем возвращаемое функцией значение переменной «x»
////let y = 7 + sqrt(4) // используем результат функции в выражении
//
//
////Будет ли функция принимать или возвращать параметры, описывается при ее определении. Количество входных параметров не ограничено, а выходной может быть только один. Конечно, вы можете вернуть один кортеж с несколькими значениями.
//
////func имя_функции ( внешнее_имя_параметра внутреннее_имя_параметра: тип_параметра ) -> тип_возвращаемого_значения
////func имя_функции ( внешнее_и_внутреннее_имя_параметра: тип_параметра ) -> тип_возвращаемого_значения
////func имя_функции ( _ внутреннее_имя_параметра: тип_параметра ) -> тип_возвращаемого_значения
//
////Любой параметр можно сделать передаваемым по ссылке, а не по назначению. Другими словами, он будет не копироваться внутрь функции, а передаваться как есть, и его можно будет менять. Для этого параметр надо пометить ключевым словом «inout», а передаваемую переменную – символом «&».
////Еще одной особенностью области видимости является то, что ее можно покинуть. При этом выполнение кода внутри области прервется, а программа продолжит выполняться в месте выхода из этой области. Таких оператора четыре:
////«break» – используется в циклах, немедленно прерывает выполнение цикла.
////«continue» – используется в циклах, немедленно переходит к следующей итерации цикла.
////«return» – используется внутри методов и функции, возвращает значение и покидает область видимости.
////«guard» – проверяет условие; если условие ложно, покидает область видимости. Важно понимать, что сам по себе «guard» область видимости покинуть не может, вы должны сами реализовать способ выхода в блоке «else», указав одну из подходящих конструкций, перечисленных выше.
//
//
////Сложные типы данных ( класс, структура - урок 3)
////«Сравнение классов и структур
////«Заметка
////Экземпляр класса традиционно называют объектом. Тем не менее, классы и структуры в Swift гораздо ближе по функциональности, чем в других языках, и многое в этой главе описывает функциональность, которую можно применить к экземплярам и класса, и структуры. В связи с этим, употребляется более общий термин - экземпляр.»
//
////Отрывок из книги: Apple Inc. «SwiftBook». iBooks.
////Классы и структуры в Swift имеют много общего. И в классах и в структурах можно:
////•    Объявлять свойства для хранения значений
////•    Объявлять методы, чтобы обеспечить функциональность
////•    Объявлять индексы, чтобы обеспечить доступ к их значениям, через синтаксис индексов
////•    Объявлять инициализаторы, чтобы установить их первоначальное состояние
////•    Они оба могут быть расширены, чтобы расширить их функционал за пределами стандартной реализации
////•    Они оба могут соответствовать протоколам, для обеспечения стандартной функциональности определенного типа
////Для получения дополнительной информации смотрите главы Свойства, Методы, Индексы, Инициализация, Расширения и Протоколы.
////Классы имеют дополнительную возможность, которых нет у структур:
////•    Наследование позволяет одному классу наследовать характеристики другого
////•    Приведение типов позволяет проверить и интерпретировать тип экземпляра класса в процессе выполнения
////•    Деинициализаторы позволяют экземпляру класса освободить любые ресурсы, которые он использовал
////Подсчет ссылок допускает более чем одну ссылку на экземпляр класса. Для получения дополнительной информации смотрите »
//
////Отрывок из книги: Apple Inc. «SwiftBook». iBooks.
//
////struct Resolution {
////    var width = 0
////    var height = 0
////}
////class VideoMode {
////    var resolution = Resolution()
////    var interlaced = false
////    var frameRate = 0.0
////    var name: String?
////}
//
//
//
////Протоколы и расширения
////
////Используйте оператор protocol для объявления протокола.
////
////protocol ExampleProtocol {
////    var simpleDescription: String { get }
////    mutating func adjust()
////}
////Классы, перечисления, и структуры могут соответствовать протоколам.
////
////class SimpleClass: ExampleProtocol {
////    var simpleDescription: String = "A very simple class."
////    var anotherProperty: Int = 69105
////    func adjust() {
////        simpleDescription += "  Now 100% adjusted."
////    }
////}
////var a = SimpleClass()
////a.adjust()
////let aDescription = a.simpleDescription
////
////struct SimpleStructure: ExampleProtocol {
////    var simpleDescription: String = "A simple structure"
////    mutating func adjust() {
////        simpleDescription += " (adjusted)"
////    }
////}
////var b = SimpleStructure()
////b.adjust()
////let bDescription = b.simpleDescription
////Обратите внимание на использование ключевого слова mutating в объявлении SimpleStructure, оно обозначает метод который модифицирует структуру. Объявление SimpleClass не нуждается в mutating методах, так как методы класса всегда могут модифицировать класс.
//
////Используйте оператор extension (расширение) для того чтобы добавить новый функционал для существующего типа, такой как объявление новых методов и вычисляемых свойств. Вы можете использовать расширение для добавления совместимости с протоколом типу, который объявлен в другом месте, или даже типу, который вы импортировали из библиотеки или фреймворка:
////extension Int: ExampleProtocol {
////    var simpleDescription: String {
////        return "The number \(self)"
////    }
////    mutating func adjust() {
////        self += 42
////    }
////}
////print(7.simpleDescription)
//
////Вы можете использовать имя протокола точно так же как другие именованные типы, например, чтобы создать коллекцию объектов, которые имеют разные типы, но все соответствуют одному протоколу. Когда вы работаете со значениями, чей тип - протокол, методы за пределами объявления протокола не доступны.
////
////let protocolValue: ExampleProtocol = a
////print(protocolValue.simpleDescription)
////// print(protocolValue.anotherProperty) // Раcкомментируйте, чтобы увидеть ошибку
////Несмотря на то, что переменная protocolValue имеет исполняемый тип SimpleClass, компилятор обрабатывает его тип как присвоенный ему ExampleProtocol. Это означает, что вы не сможете случайно получить доступ к методам или свойствам, которые класс реализует в дополнение для соответствия протоколу.
//
//
////Неправильные ответы: 12
////Swift не позволяет использовать шаблоны для протоколов, но возможно ли каким-либо образом указать тип как шаблонный?
////
////Ваш ответ
////да, на самом деле шаблоны можно использовать и с протоколами
//
////Правильный ответ: не знаю.
////
////универсальная функция:
////func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
////    let temporaryA = a
////    a = b
////    b = temporaryA
////}
////
//////универсальная структура Stack:
////struct Stack<Element> {
////    var items = [Element]()
////    mutating func push(_ item: Element) {
////        items.append(item)
////    }
////    mutating func pop() -> Element {
////        return items.removeLast()
////    }
////}
////Шаблон представляет собой структуру одного значения или составного значения. Например, структура кортежа (1, 2) представляет собой разделенный запятыми список, состоящий из двух элементов. Поскольку шаблоны представляют структуру значения, а не какое-либо конкретное значение, вы можете сопоставить их с различными значениями. Например, шаблон (x, y) совпадает с кортежем (1, 2), а также с любым другим кортежем, состоящем из двух элементов. В дополнение к тому, что шаблон совпадает с значением, вы также можете извлечь часть или всё составное значение и связать каждую его часть с именем константы или переменной.
////
////В Swift существует два основных вида шаблонов: те, которые совпадают с каким-либо значением, и те, которые могут не совпадать с заданным значением во время выполнения.
////
////Первый вид шаблона используется для деструктуризации значений в простой переменной, константе и опциональных привязках. К ним относятся подстановочные шаблоны, шаблоны идентификаторов и любые значения связывания или кортежи шаблонов их содержащие. Вы можете указать аннотацию типа для этих шаблонов, чтобы ограничить их, для соответствия только значениям определенного типа.
////
////Второй вид шаблона используется для полного совпадения с шаблоном, где значение, с которым вы пытаетесь совпасть, может не находится там во время выполнения. Сюда включены шаблоны кейсов перечисления, опциональные шаблоны, шаблоны выражений и шаблоны приведения типов. Вы можете использовать эти шаблоны в ярлыках кейсов инструкции switch, в условии catch инструкции do, или в условии инструкции if, while, guard, или for-in.
//
////
////На какие типы можно добавить функциональность с помощью расширения?
////
////Ваш ответ
////только на класс
////Правильный ответ: как минимум структуры и классы
//
//
//
//
//
////
////В коде ниже объявлен класс и структура, чем являются константы - structObj и classObj?
////
////Ваш ответ
////оба являются объектами
//
//
//
////Объект – это экземпляр класса или структуры. Так что же такое структура?
//
//
////Структуры поддерживают многие характерные черты классов, в том числе методы и инициализаторы. Одно из наиболее важных различий между классами и структурами в том, что структуры всегда копируются когда они передаются в коде, а классы, передаются по ссылке.
////
////struct Card {
////    var rank: Rank
////    var suit: Suit
////    func simpleDescription() -> String {
////        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
////    }
////}
////let threeOfSpades = Card(rank: .three, suit: .spades)
////let threeOfSpadesDescription = threeOfSpades.simpleDescription()
////класс - ссылочный тип???
////экземпляр класса - объект?
//
//
////«Заметка
////Экземпляр класса традиционно называют объектом. Тем не менее, классы и структуры в Swift гораздо ближе по функциональности, чем в других языках, и многое в этой главе описывает функциональность, которую можно применить к экземплярам и класса, и структуры. В связи с этим, употребляется более общий термин - экземпляр.»
//
//
////Экземпляры класса и структуры
////Объявление структуры Resolution и класса VideoMode только описывают как Resolution и VideoMode будут выглядеть. Сами по себе они не описывают специфическое разрешение или видеорежим. Для того чтобы это сделать нам нужно создать экземпляр структуры или класса.
////
////Синтаксис для образования экземпляра класса или структуры очень схож:
////
////let someResolution = Resolution()
////let someVideoMode = VideoMode()
////И классы и структуры используют синтаксис инициализатора для образования новых экземпляров. Самая простая форма синтаксиса инициализатора - использование имени типа и пустые круглые скобки сразу после него Resolution(), VideoMode(). Это создает новый экземпляр класса или структуры с любыми инициализированными свойствами с их значениями по умолчанию. Классы и структуры инициализации описаны более подробно в главе Инициализация.
//
////Классы - ссылочный тип
////В отличии от типа значений, ссылочный тип не копируется, когда его присваивают переменной или константе, или когда его передают функции. Вместо копирования используется ссылка на существующий экземпляр.
////класс – это ссылочный тип. Это означает, что в переменной хранится не само значение, а ссылка на него. Когда мы присваиваем одной переменной типа класс значение другой переменной, мы копируем не сам объект, а ссылку. В результате у нас две переменных, которые содержат ссылки на один и тот же объект в памяти.
////Структуры, как и простые типы данных, являются типом значения. Это означает, что в переменных хранится само значение структуры. Когда мы присваиваем значение одной переменной другой, мы фактически полностью копируем содержимое переменной. После создания копии в обеих переменных находятся два разных экземпляра структуры, но с одинаковыми значениями.
//
//
////
////Вот пример с использованием класса VideoMode, который был объявлен выше:
////
////let tenEighty = VideoMode()
////tenEighty.resolution = hd
////tenEighty.interlaced = true
////tenEighty.name = "1080i"
////tenEighty.frameRate = 25.0
////В этом примере объявляем новую константу tenEighty и устанавливаем ссылку на новый экземпляр класса VideoMode. Значения видеорежима были присвоены копией со значениями 1920 на 1080. Мы ставим tenEighty.interlaced = true и даем имя “1080i”. Затем устанавливаем частоту кадров в секунду 25 .
////
////Следующее, что мы сделаем, это tenEighty присвоим новой константе alsoTenEighty и изменим частоту кадров:
////
////let alsoTenEighty = tenEighty
////alsoTenEighty.frameRate = 30.0
////Так как это классы ссылочного типа, то экземпляры tenEighty и alsoTenEighty ссылаются на один и тот же экземпляр VideoMode. Фактически получается, что у нас два разных имени для одного единственного экземпляра, как показано на рисунке ниже:
////
////
////Если мы проверим свойство frameRate у tenEighty, то мы увидим, что новая частота кадров 30.0, которая берется у экземпляра VideoMode:
////
////print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
////// Выведет "The frameRate property of tenEighty is now 30.0"
////Этот пример показывает как сложно бывает отследить за ссылочными типами. Если tenEighty и alsoTenEighty находились бы в разных уголках вашей программы, то было бы сложно найти все места, где мы меняем режим воспроизведения видео. Где бы вы не использовали tenEighty, вам так же бы приходилось думать и о alsoTenEighty, и наоборот. В отличии от ссылочного типа, с типами значения дела обстоят значительно проще, так как весь код, который взаимодействует с одним и тем же значением, находится рядом, в вашем исходном файле.
////
////Обратите внимание, что tenEighty и alsoTenEighty объявлены как константы, а не переменные. Однако вы все равно можете менять tenEighty.frameRate и alsoTenEighty.frameRate, потому что значения tenEighty и alsoTenEighty сами по себе не меняются, так как они не «содержат» значение экземпляра VideoMode, а напротив, они лишь ссылаются на него. Это свойство frameRate лежащего в основе VideoMode, которое меняется, а не значения константы ссылающейся на VideoMode.
//
////Свойства
////Свойства похожи на переменные. Но в отличие от переменных, они не существуют сами по себе, а являются частью структуры. Любая структура может хранить сколько угодно любых свойств.
////Например, у структуры «Honda» мы объявили 5 свойств: color, mp3, transmission, km и doorState. А когда мы инициализировали машины, мы указали значения для них. К любым свойствам можно получить доступ, но переустановить значение можно, только если свойство и сам объект не объявлены как константа.
//
////Свойства и методы класса
////Мы уже достаточно понимаем концепцию «класс-объект», чтобы поговорить о свойствах и методах класса. Все свойства и методы, что мы объявляли, принадлежали объектам. Это означает, что только готовый автомобиль имеет свойства пробега, трансмиссии и прочие. Только у готового автомобиля имеются методы открытия и закрытия дверей. Это логично – чертеж не может открывать и закрывать двери. Но дело в том, что у класса могут быть свои свойства. Они доступны только при обращении к классу. Он существует в единственном экземпляре, поэтому когда бы мы к нему ни обратились, мы будем читать и писать одно и то же свойство. Это же касается и методов. Вы даже имели дело с особенным методом класса – это конструктор. Если помните, мы вызывали его, обращаясь к классу, а вот у инициализированной машины конструктор уже недоступен.
//
//
//
////
////В каком случае лучше использовать структуру, а не класс?
////
////Ваш ответ
////Когда нам нужно инкапсулировать сложные наборы значений
////
////Структуры подходят, если выполняется одно или несколько условий:
//
////Инкапсуляция небольшого набора простых значений.
////Значения следует копировать, а не передавать по ссылке.
////Свойства самой структуры — value-типы, которые тоже передаются по значению.
////Структуры не наследует свойства или поведения.
////Хорошие примеры:
////
////Размеры фигуры: ширина и высота.
////Точка в пространства: x, y и z типа double.
////В большинстве случаев следует использовать классы.
////
////Предлагаю такие вопросы себе задавать:
////1) Нужно ли мне наследование?
////2) Нужно ли использовать классовые дженерики ('class SomeClass: ClassName')?
////3) Нужно ли будет такое, чтобы инстанс объекта был доступен из нескольких мест и его можно было менять из них. (объект по ссылке, вместо копирования)?
////4) Нужен ли деинициализатор?
////
////Если на все ответ нет, то используйте структуру.
//
//
//
//
//
////Можно ли ограничить протокол, чтобы его могли поддерживать только классы?
////
////Ваш ответ
////нет
//
////Классы, перечисления, и структуры могут соответствовать протоколам.
//
//
//
//
//
////
////Для чего нужны автозамыкания?
////
////Ваш ответ
////для того что бы сохранять значение переменных внутри замыкания
////
////Автозамыкания (autoclosures)
////Автозамыкания - замыкания, которые автоматически создаются для заключения выражения, которое было передано в качестве аргумента функции. Такие замыкания не принимают никаких аргументов при вызове и возвращают значение выражения, которое заключено внутри нее. Синтаксически вы можете опустить круглые скобки функции вокруг параметров функции, просто записав обычное выражение вместо явного замыкания.
////Нет ничего необычного в вызове функций, которые принимают автозамыкания, но необычным является реализовывать такие функции. Например, функция assert(condition:message:file:line:) принимает автозамыкания на место condition и message параметров. Ее параметр condition вычисляется только в сборке дебаггера, а параметр message вычисляется, если только condition равен false.
////Автозамыкания позволяют вам откладывать вычисления, потому как код внутри них не исполняется, пока вы сами его не запустите. Это полезно для кода, который может иметь сторонние эффекты или просто является дорогим в вычислительном отношении, потому что вы можете контролировать время исполнения этого кода. Пример ниже отображает как замыкания откладывают вычисления:
//
////var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
////print(customersInLine.count)
//// Выведет "5"
////
////let customerProvider = { customersInLine.remove(at: 0) }
////print(customersInLine.count)
//// Выведет "5"
////
////print("Now serving \(customerProvider())!")
//// Выведет "Now serving Chris!"
////print(customersInLine.count)
//// Выведет "4"
//
////Даже если первый элемент массива customersInLine удаляется кодом внутри замыкания, элемент массива фактически не удаляется до тех пор пока само замыкание не будет вызвано. Если замыкание так и не вызывается, то выражение внутри него никогда не выполнится и, соответственно, элемент не будет удален из массива. Обратите внимание, что customerProvider является не String, а () -> String, то есть функция не принимает аргументов, но возвращает строку. Вы получите то же самое поведение, когда сделаете это внутри функции:
//
//// customersInLine равен ["Alex", "Ewa", "Barry", "Daniella"]
//
////func serve(customer customerProvider: () -> String) {
////    print("Now serving \(customerProvider())!")
////}
////serve(customer: { customersInLine.remove(at: 0) } )
//// Выведет "Now serving Alex!"
//
////Функция serve(customer:) описанная выше принимает явное замыкание, которое возвращает имя клиента. Версия функции serve(customer:) ниже выполняет ту же самую операцию, но вместо использования явного замыкания, она использует автозамыкание, поставив маркировку при помощи атрибута @autoclosure. Теперь вы можете вызывать функцию, как будто бы она принимает аргумент String вместо замыкания. Аргумент автоматически преобразуется в замыкание, потому что тип параметра customerProvider имеет атрибут @autoclosure.
//
//// customersInLine равен ["Ewa", "Barry", "Daniella"]
////func serve(customer customerProvider: @autoclosure () -> String) {
////    print("Now serving \(customerProvider())!")
////}
////serve(customer: customersInLine.remove(at: 0))
//// Выведет "Now serving Ewa!"
////Заметка
////Слишком частое использование автозамыканий может сделать ваш код сложным для чтения. Контекст и имя функции должны обеспечивать ясность отложенности исполнения кода.
//
////Если вы хотите чтобы автозамыкание могло сбежать, то вам нужно использовать оба атрибута и @autoclosure, и @escaping. Атрибут @escaping подробнее описан в главе Сбегающие замыкания.
//
//// customersInLine равен ["Barry", "Daniella"]
////var customerProviders: [() -> String] = []
////func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
////    customerProviders.append(customerProvider)
////}
////collectCustomerProviders(customersInLine.remove(at: 0))
////collectCustomerProviders(customersInLine.remove(at: 0))
////
////print("Collected \(customerProviders.count) closures.")
//// Выведет "Collected 2 closures."
////for customerProvider in customerProviders {
////    print("Now serving \(customerProvider())!")
////}
//
//// Выведет "Now serving Barry!"
//// Выведет "Now serving Daniella!"
//
//
////В коде выше, вместо того, чтобы вызывать переданное замыкание в качестве аргумента customer, функция collectCustomerProviders(_:) добавляет замыкание к массиву customerProviders. Массив объявлен за пределами функции, что означает, что замыкание в массиве может быть исполнено после того, как функция вернет значение. В результате значение аргумента customerProvider должен иметь “разрешение” на “побег” из зоны видимости функции.
//
//
//
////Что означает ключевое слово              @escaping?
////
////Ваш ответ
////ничего, такого нет в swift
////Сбегающие замыкания
////Когда говорят, что замыкание сбегает из функции, то это значит, что это замыкание было передано в функцию в качестве аргумента и вызывается уже после того, как функция вернула значение. Когда вы объявляете функцию, которая имеет замыкание в качестве одного из параметров, то вы пишите @escaping до типа параметра, для того чтобы указать, что замыкание может сбежать.
//
////Если замыкание хранится в переменной, которая была объявлена вне функции, а затем эта переменная была передана в качестве аргумента в функцию, то получается, что замыкание, которое посредством переменной передается в функцию, сбегающее. В качестве примера можно рассмотреть функции, которые выполняют асинхронные операции в завершающем обработчике, который является замыканием.То есть получается, что функция завершает свою работу, после чего вызывается завершающий обработчик. Или другими словами обработчик не вызывается, пока не завершится работа функции, таким образом получается, что данному замыканию нужно сбежать из области работы функции, чтобы отработать позже. Например:
//
////var completionHandlers: [() -> Void] = []
////func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
////    completionHandlers.append(completionHandler)
////}
////Функция someFunctionWithEscapingClosure(_:) принимает и добавляет в массив замыкание, объявленное за пределами функции. Если вы не поставите маркировку @escaping, то получите ошибку компиляции.
//
////Определение замыкания через @escaping означает, что вы должны сослаться на self явно внутри самого замыкания. Например, в коде ниже, замыкание передается функции someFunctionWithEscapingClosure(_:) в виде сбегающего замыкания, так что вам нужно ссылаться на self внутри него явно. С другой стороны, замыкание, передаваемое в someFunctionWithNonescapingClosure(_:) является не сбегающим, значит вы можете ссылаться на self неявно.
//
////func someFunctionWithNonescapingClosure(closure: () -> Void) {
////    closure()
////}
////
////class SomeClass {
////    var x = 10
////    func doSomething() {
////        someFunctionWithEscapingClosure { self.x = 100 }
////        someFunctionWithNonescapingClosure { x = 200 }
////    }
////}
////
////let instance = SomeClass()
////instance.doSomething()
////print(instance.x)
////Выведет "200"
////
////completionHandlers.first?()
////print(instance.x)
////Выведет "100"
//
//
//
//
//
//
////Можно ли через расширение добавить поддержку того или иного протокола?
////
////Ваш ответ
////нет, только добавить методы
////
//
//
//
//
////Что выведет следующий код:
////
////Ваш ответ
////0,1,2,3,...,10
////
////Верен ли следующий код:
////
////Ваш ответ
////нет
////
////Что выведет следующий код:
////
////Ваш ответ
////hello world!
//
//
//

//let x = 10
//switch x {
//case 0 : print("0")
//case 1 : print("1")
//default : print("er")
//}
//Неправильные ответы: 9
//Корректно ли условие:
//
//Ваш ответ
//да, верно
//
//Что выведет в консоль данный код:
//
//Ваш ответ
//2 и 4
//
//
//
//Захватывают ли замыкания ссылку self?
//
//Ваш ответ
//да, но только как слабую ссылку
//
//Что выведет в консоль данный код:
//
//Ваш ответ
//“hello”
//
//
//
//Выберите вариант, где верно объявлен вызов функции:
//
//Ваш ответ
//let str = func hello(name : “world”)
//
//Что выведет в консоль данный код:
//
//Ваш ответ
//4
//
//Верен ли следующий код:
//
//Ваш ответ
//нет
//
//Что выведет следующий код:
//
//Ваш ответ
//будет ошибка
//
//Что может требовать протокол?
//
//Ваш ответ
//только переменные экземпляра и типа(static)
